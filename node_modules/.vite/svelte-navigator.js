import {
  derived,
  writable
} from "./chunk-SOHKAKNE.js";
import "./chunk-3BQGYF6B.js";
import {
  getContext,
  get_store_value,
  onDestroy,
  tick
} from "./chunk-YN2TDSR3.js";

// node_modules/svelte-navigator/src/index.js
import { default as default2 } from "/home/ig/dev/github.com/icaroglauco-lab/designImpl-svelTemplate/node_modules/svelte-navigator/src/Router.svelte";
import { default as default3 } from "/home/ig/dev/github.com/icaroglauco-lab/designImpl-svelTemplate/node_modules/svelte-navigator/src/Route.svelte";
import { default as default4 } from "/home/ig/dev/github.com/icaroglauco-lab/designImpl-svelTemplate/node_modules/svelte-navigator/src/Link.svelte";

// node_modules/svelte-navigator/src/paths.js
var paramRegex = /^:(.+)/;
var startsWith = (string, search) => string.substr(0, search.length) === search;
var isRootSegment = (segment) => segment === "";
var isDynamic = (segment) => paramRegex.test(segment);
var isSplat = (segment) => segment[0] === "*";
var stripSlashes = (str) => str.replace(/(^\/+|\/+$)/g, "");
function segmentize(uri, filterFalsy = false) {
  const segments = stripSlashes(uri).split("/");
  return filterFalsy ? segments.filter(Boolean) : segments;
}
var addQuery = (pathname, query) => pathname + (query ? `?${query}` : "");
var normalizePath = (path) => `/${stripSlashes(path)}`;
function join(...pathFragments) {
  const joinFragment = (fragment) => segmentize(fragment, true).join("/");
  const joinedSegments = pathFragments.map(joinFragment).join("/");
  return normalizePath(joinedSegments);
}

// node_modules/svelte-navigator/src/utils.js
var isUndefined = (value) => typeof value === "undefined";
var isFunction = (value) => typeof value === "function";
var isNumber = (value) => typeof value === "number";
function shouldNavigate(event) {
  return !event.defaultPrevented && event.button === 0 && !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function createGlobalId() {
  return Math.random().toString(36).substring(2);
}
function findClosest(tagName, element) {
  while (element && element.tagName !== tagName) {
    element = element.parentNode;
  }
  return element;
}
var isSSR = typeof window === "undefined";
function addListener(target, type, handler) {
  target.addEventListener(type, handler);
  return () => target.removeEventListener(type, handler);
}

// node_modules/svelte-navigator/src/warning.js
var LINK_ID = 1;
var ROUTE_ID = 2;
var ROUTER_ID = 3;
var USE_FOCUS_ID = 4;
var USE_LOCATION_ID = 5;
var USE_MATCH_ID = 6;
var USE_NAVIGATE_ID = 7;
var USE_PARAMS_ID = 8;
var USE_RESOLVABLE_ID = 9;
var USE_RESOLVE_ID = 10;
var NAVIGATE_ID = 11;
var labels = {
  [LINK_ID]: "Link",
  [ROUTE_ID]: "Route",
  [ROUTER_ID]: "Router",
  [USE_FOCUS_ID]: "useFocus",
  [USE_LOCATION_ID]: "useLocation",
  [USE_MATCH_ID]: "useMatch",
  [USE_NAVIGATE_ID]: "useNavigate",
  [USE_PARAMS_ID]: "useParams",
  [USE_RESOLVABLE_ID]: "useResolvable",
  [USE_RESOLVE_ID]: "useResolve",
  [NAVIGATE_ID]: "navigate"
};
var createLabel = (labelId) => labels[labelId];
function createIdentifier(labelId, props) {
  let attr;
  if (labelId === ROUTE_ID) {
    attr = props.path ? `path="${props.path}"` : "default";
  } else if (labelId === LINK_ID) {
    attr = `to="${props.to}"`;
  } else if (labelId === ROUTER_ID) {
    attr = `basepath="${props.basepath || ""}"`;
  }
  return `<${createLabel(labelId)} ${attr || ""} />`;
}
function createMessage(labelId, message, props, originId) {
  const origin = props && createIdentifier(originId || labelId, props);
  const originMsg = origin ? `

Occurred in: ${origin}` : "";
  const label = createLabel(labelId);
  const msg = isFunction(message) ? message(label) : message;
  return `<${label}> ${msg}${originMsg}`;
}
var createMessageHandler = (handler) => (...args) => handler(createMessage(...args));
var fail = createMessageHandler((message) => {
  throw new Error(message);
});
var warn = createMessageHandler(console.warn);

// node_modules/svelte-navigator/src/routes.js
var SEGMENT_POINTS = 4;
var STATIC_POINTS = 3;
var DYNAMIC_POINTS = 2;
var SPLAT_PENALTY = 1;
var ROOT_POINTS = 1;
function rankRoute(route, index) {
  const score = route.default ? 0 : segmentize(route.fullPath).reduce((acc, segment) => {
    let nextScore = acc;
    nextScore += SEGMENT_POINTS;
    if (isRootSegment(segment)) {
      nextScore += ROOT_POINTS;
    } else if (isDynamic(segment)) {
      nextScore += DYNAMIC_POINTS;
    } else if (isSplat(segment)) {
      nextScore -= SEGMENT_POINTS + SPLAT_PENALTY;
    } else {
      nextScore += STATIC_POINTS;
    }
    return nextScore;
  }, 0);
  return { route, score, index };
}
function rankRoutes(routes) {
  return routes.map(rankRoute).sort((a, b) => {
    if (a.score < b.score) {
      return 1;
    }
    if (a.score > b.score) {
      return -1;
    }
    return a.index - b.index;
  });
}
function pick(routes, uri) {
  let bestMatch;
  let defaultMatch;
  const [uriPathname] = uri.split("?");
  const uriSegments = segmentize(uriPathname);
  const isRootUri = uriSegments[0] === "";
  const ranked = rankRoutes(routes);
  for (let i = 0, l = ranked.length; i < l; i++) {
    const { route } = ranked[i];
    let missed = false;
    const params = {};
    const createMatch = (uri2) => ({ ...route, params, uri: uri2 });
    if (route.default) {
      defaultMatch = createMatch(uri);
      continue;
    }
    const routeSegments = segmentize(route.fullPath);
    const max = Math.max(uriSegments.length, routeSegments.length);
    let index = 0;
    for (; index < max; index++) {
      const routeSegment = routeSegments[index];
      const uriSegment = uriSegments[index];
      if (!isUndefined(routeSegment) && isSplat(routeSegment)) {
        const splatName = routeSegment === "*" ? "*" : routeSegment.slice(1);
        params[splatName] = uriSegments.slice(index).map(decodeURIComponent).join("/");
        break;
      }
      if (isUndefined(uriSegment)) {
        missed = true;
        break;
      }
      const dynamicMatch = paramRegex.exec(routeSegment);
      if (dynamicMatch && !isRootUri) {
        const value = decodeURIComponent(uriSegment);
        params[dynamicMatch[1]] = value;
      } else if (routeSegment !== uriSegment) {
        missed = true;
        break;
      }
    }
    if (!missed) {
      bestMatch = createMatch(join(...uriSegments.slice(0, index)));
      break;
    }
  }
  return bestMatch || defaultMatch || null;
}
function match(route, uri) {
  return pick([route], uri);
}
function resolve(to, base) {
  if (startsWith(to, "/")) {
    return to;
  }
  const [toPathname, toQuery] = to.split("?");
  const [basePathname] = base.split("?");
  const toSegments = segmentize(toPathname);
  const baseSegments = segmentize(basePathname);
  if (toSegments[0] === "") {
    return addQuery(basePathname, toQuery);
  }
  if (!startsWith(toSegments[0], ".")) {
    const pathname = baseSegments.concat(toSegments).join("/");
    return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
  }
  const allSegments = baseSegments.concat(toSegments);
  const segments = [];
  allSegments.forEach((segment) => {
    if (segment === "..") {
      segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return addQuery(`/${segments.join("/")}`, toQuery);
}
function normalizeLocation(location, basepath) {
  const { pathname, hash = "", search = "", state } = location;
  const baseSegments = segmentize(basepath, true);
  const pathSegments = segmentize(pathname, true);
  while (baseSegments.length) {
    if (baseSegments[0] !== pathSegments[0]) {
      fail(ROUTER_ID, `Invalid state: All locations must begin with the basepath "${basepath}", found "${pathname}"`);
    }
    baseSegments.shift();
    pathSegments.shift();
  }
  return {
    pathname: join(...pathSegments),
    hash,
    search,
    state
  };
}
var normalizeUrlFragment = (frag) => frag.length === 1 ? "" : frag;
function createLocation(url) {
  const searchIndex = url.indexOf("?");
  const hashIndex = url.indexOf("#");
  const hasSearchIndex = searchIndex !== -1;
  const hasHashIndex = hashIndex !== -1;
  const hash = hasHashIndex ? normalizeUrlFragment(url.substr(hashIndex)) : "";
  const pathnameAndSearch = hasHashIndex ? url.substr(0, hashIndex) : url;
  const search = hasSearchIndex ? normalizeUrlFragment(pathnameAndSearch.substr(searchIndex)) : "";
  const pathname = hasSearchIndex ? pathnameAndSearch.substr(0, searchIndex) : pathnameAndSearch;
  return { pathname, search, hash };
}
function resolveLink(path, routeBase, appBase) {
  return join(appBase, resolve(path, routeBase));
}

// node_modules/svelte-navigator/src/history.js
var POP = "POP";
var PUSH = "PUSH";
var REPLACE = "REPLACE";
function getLocation(source) {
  return {
    ...source.location,
    pathname: encodeURI(decodeURI(source.location.pathname)),
    state: source.history.state,
    _key: source.history.state && source.history.state._key || "initial"
  };
}
function createHistory(source) {
  let listeners = [];
  let location = getLocation(source);
  let action = POP;
  const notifyListeners = (listenerFns = listeners) => listenerFns.forEach((listener) => listener({ location, action }));
  return {
    get location() {
      return location;
    },
    listen(listener) {
      listeners.push(listener);
      const popstateListener = () => {
        location = getLocation(source);
        action = POP;
        notifyListeners([listener]);
      };
      notifyListeners([listener]);
      const unlisten = addListener(source, "popstate", popstateListener);
      return () => {
        unlisten();
        listeners = listeners.filter((fn) => fn !== listener);
      };
    },
    navigate(to, options) {
      const { state = {}, replace = false } = options || {};
      action = replace ? REPLACE : PUSH;
      if (isNumber(to)) {
        if (options) {
          warn(NAVIGATE_ID, "Navigation options (state or replace) are not supported, when passing a number as the first argument to navigate. They are ignored.");
        }
        action = POP;
        source.history.go(to);
      } else {
        const keyedState = { ...state, _key: createGlobalId() };
        try {
          source.history[replace ? "replaceState" : "pushState"](keyedState, "", to);
        } catch (e) {
          source.location[replace ? "replace" : "assign"](to);
        }
      }
      location = getLocation(source);
      notifyListeners();
    }
  };
}
function createStackFrame(state, uri) {
  return { ...createLocation(uri), state };
}
function createMemorySource(initialPathname = "/") {
  let index = 0;
  let stack = [createStackFrame(null, initialPathname)];
  return {
    get entries() {
      return stack;
    },
    get location() {
      return stack[index];
    },
    addEventListener() {
    },
    removeEventListener() {
    },
    history: {
      get state() {
        return stack[index].state;
      },
      pushState(state, title, uri) {
        index++;
        stack = stack.slice(0, index);
        stack.push(createStackFrame(state, uri));
      },
      replaceState(state, title, uri) {
        stack[index] = createStackFrame(state, uri);
      },
      go(to) {
        const newIndex = index + to;
        if (newIndex < 0 || newIndex > stack.length - 1) {
          return;
        }
        index = newIndex;
      }
    }
  };
}
var canUseDOM = !!(!isSSR && window.document && window.document.createElement);
var isEmbeddedPage = !isSSR && window.location.origin === "null";
var globalHistory = createHistory(canUseDOM && !isEmbeddedPage ? window : createMemorySource());
var { navigate } = globalHistory;

// node_modules/svelte-navigator/src/actions.js
var createAction = (getAnchor) => (node, navigate2 = navigate) => {
  const handleClick = (event) => {
    const anchor = getAnchor(event);
    if (anchor && anchor.target === "" && shouldNavigate(event)) {
      event.preventDefault();
      const to = anchor.pathname + anchor.search + anchor.hash;
      navigate2(to, { replace: anchor.hasAttribute("replace") });
    }
  };
  const unlisten = addListener(node, "click", handleClick);
  return { destroy: unlisten };
};
var link = createAction((event) => event.currentTarget);
var links = createAction((event) => {
  const anchor = findClosest("A", event.target);
  if (anchor && isFunction(anchor.hasAttribute) && !anchor.hasAttribute("noroute")) {
    return anchor;
  }
  return null;
});

// node_modules/svelte-navigator/src/contexts.js
var createKey = (ctxName) => `@@svnav-ctx__${ctxName}`;
var LOCATION = createKey("LOCATION");
var ROUTER = createKey("ROUTER");
var ROUTE = createKey("ROUTE");
var ROUTE_PARAMS = createKey("ROUTE_PARAMS");
var FOCUS_ELEM = createKey("FOCUS_ELEM");

// node_modules/svelte-navigator/src/hooks.js
function usePreflightCheck(componentId, props, ctxKey = ROUTER, ctxProviderId = ROUTER_ID) {
  const ctx = getContext(ctxKey);
  if (!ctx) {
    fail(componentId, (label) => `You cannot use ${label} outside of a ${createLabel(ctxProviderId)}.`, props);
  }
}
var toReadonly = (ctx) => {
  const { subscribe } = getContext(ctx);
  return { subscribe };
};
function useLocation() {
  usePreflightCheck(USE_LOCATION_ID);
  return toReadonly(LOCATION);
}
function useHistory() {
  const { history } = getContext(ROUTER);
  return history;
}
function useRouteBase() {
  const route = getContext(ROUTE);
  return route ? derived(route, (_route) => _route.base) : writable("/");
}
function useResolve() {
  usePreflightCheck(USE_RESOLVE_ID);
  const routeBase = useRouteBase();
  const { basepath: appBase } = getContext(ROUTER);
  const resolve2 = (path) => resolveLink(path, get_store_value(routeBase), appBase);
  return resolve2;
}
function useResolvable(path) {
  usePreflightCheck(USE_RESOLVABLE_ID);
  const routeBase = useRouteBase();
  const { basepath: appBase } = getContext(ROUTER);
  return derived(routeBase, (_routeBase) => resolveLink(path, _routeBase, appBase));
}
function useNavigate() {
  usePreflightCheck(USE_NAVIGATE_ID);
  const resolve2 = useResolve();
  const { navigate: navigate2 } = useHistory();
  const navigateRelative = (to, options) => {
    const target = isNumber(to) ? to : resolve2(to);
    return navigate2(target, options);
  };
  return navigateRelative;
}
function useMatch(path) {
  usePreflightCheck(USE_MATCH_ID);
  const location = useLocation();
  const resolve2 = useResolve();
  const { basepath: appBase } = getContext(ROUTER);
  const resolvedPath = resolve2(path);
  const { pathname: fullPath } = normalizeLocation({ pathname: resolvedPath }, appBase);
  return derived(location, (loc) => match({ fullPath, path }, loc.pathname));
}
function useParams() {
  usePreflightCheck(USE_PARAMS_ID, null, ROUTE, ROUTE_ID);
  return toReadonly(ROUTE_PARAMS);
}
function useFocus() {
  usePreflightCheck(USE_FOCUS_ID, null, ROUTE, ROUTE_ID);
  const location = useLocation();
  const focusElement = getContext(FOCUS_ELEM);
  let resolve2;
  const unsubscribe = location.subscribe(() => {
    const lazyElement = new Promise((_resolve) => {
      resolve2 = _resolve;
    });
    focusElement.set(lazyElement);
  });
  onDestroy(unsubscribe);
  return (node) => {
    let unmounted = false;
    const innerUnsubscribe = location.subscribe(() => {
      tick().then(() => {
        if (!unmounted) {
          resolve2(node);
        }
      });
    });
    return {
      destroy() {
        unmounted = true;
        innerUnsubscribe();
      }
    };
  };
}
export {
  default4 as Link,
  default3 as Route,
  default2 as Router,
  createHistory,
  createMemorySource,
  globalHistory,
  link,
  links,
  navigate,
  useFocus,
  useLocation,
  useMatch,
  useNavigate,
  useParams,
  useResolvable,
  useResolve
};
//# sourceMappingURL=svelte-navigator.js.map
