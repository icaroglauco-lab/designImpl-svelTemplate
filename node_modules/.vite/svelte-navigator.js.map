{
  "version": 3,
  "sources": ["../svelte-navigator/src/index.js", "../svelte-navigator/src/paths.js", "../svelte-navigator/src/utils.js", "../svelte-navigator/src/warning.js", "../svelte-navigator/src/routes.js", "../svelte-navigator/src/history.js", "../svelte-navigator/src/actions.js", "../svelte-navigator/src/contexts.js", "../svelte-navigator/src/hooks.js"],
  "sourcesContent": ["/*\n * Adapted from https://github.com/EmilTholin/svelte-routing\n *\n * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE\n */\n\nexport { default as Router } from \"./Router.svelte\";\nexport { default as Route } from \"./Route.svelte\";\nexport { default as Link } from \"./Link.svelte\";\nexport {\n\tnavigate,\n\tcreateHistory,\n\tcreateMemorySource,\n\tglobalHistory,\n} from \"./history\";\nexport { link, links } from \"./actions\";\nexport {\n\tuseLocation,\n\tuseResolve,\n\tuseResolvable,\n\tuseNavigate,\n\tuseMatch,\n\tuseParams,\n\tuseFocus,\n} from \"./hooks\";\n", "export const paramRegex = /^:(.+)/;\n\n/**\n * Check if `string` starts with `search`\n * @param {string} string\n * @param {string} search\n * @return {boolean}\n */\nexport const startsWith = (string, search) =>\n\tstring.substr(0, search.length) === search;\n\n/**\n * Check if `segment` is a root segment\n * @param {string} segment\n * @return {boolean}\n */\nexport const isRootSegment = segment => segment === \"\";\n\n/**\n * Check if `segment` is a dynamic segment\n * @param {string} segment\n * @return {boolean}\n */\nexport const isDynamic = segment => paramRegex.test(segment);\n\n/**\n * Check if `segment` is a splat\n * @param {string} segment\n * @return {boolean}\n */\nexport const isSplat = segment => segment[0] === \"*\";\n\n/**\n * Strip potention splat and splatname of the end of a path\n * @param {string} str\n * @return {string}\n */\nexport const stripSplat = str => str.replace(/\\*.*$/, \"\");\n\n/**\n * Strip `str` of potential start and end `/`\n * @param {string} str\n * @return {string}\n */\nexport const stripSlashes = str => str.replace(/(^\\/+|\\/+$)/g, \"\");\n\n/**\n * Split up the URI into segments delimited by `/`\n * @param {string} uri\n * @return {string[]}\n */\nexport function segmentize(uri, filterFalsy = false) {\n\tconst segments = stripSlashes(uri).split(\"/\");\n\treturn filterFalsy ? segments.filter(Boolean) : segments;\n}\n\n/**\n * Add the query to the pathname if a query is given\n * @param {string} pathname\n * @param {string} [query]\n * @return {string}\n */\nexport const addQuery = (pathname, query) =>\n\tpathname + (query ? `?${query}` : \"\");\n\n/**\n * Combines the `basepath` and the `path` into one path.\n * @param {string} basepath\n * @param {string} path\n */\nexport function combinePaths(basepath, path) {\n\tconst barePath =\n\t\tpath === \"/\" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`;\n\treturn `${stripSlashes(barePath)}/`;\n}\n\n/**\n * Normalizes a basepath\n *\n * @param {string} path\n * @returns {string}\n *\n * @example\n * normalizePath(\"base/path/\") // -> \"/base/path\"\n */\nexport const normalizePath = path => `/${stripSlashes(path)}`;\n\n/**\n * Joins and normalizes multiple path fragments\n *\n * @param {...string} pathFragments\n * @returns {string}\n */\nexport function join(...pathFragments) {\n\tconst joinFragment = fragment => segmentize(fragment, true).join(\"/\");\n\tconst joinedSegments = pathFragments.map(joinFragment).join(\"/\");\n\treturn normalizePath(joinedSegments);\n}\n", "/*\n * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js\n *\n * https://github.com/reach/router/blob/master/LICENSE\n */\n\nexport const isUndefined = value => typeof value === \"undefined\";\n\nexport const isFunction = value => typeof value === \"function\";\n\nexport const isNumber = value => typeof value === \"number\";\n\n/**\n * Decides whether a given `event` should result in a navigation or not.\n * @param {object} event\n */\nexport function shouldNavigate(event) {\n\treturn (\n\t\t!event.defaultPrevented &&\n\t\tevent.button === 0 &&\n\t\t!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)\n\t);\n}\n\nexport function createCounter() {\n\tlet i = 0;\n\t/**\n\t * Returns an id and increments the internal state\n\t * @returns {number}\n\t */\n\treturn () => i++;\n}\n\n/**\n * Create a globally unique id\n *\n * @returns {string} An id\n */\nexport function createGlobalId() {\n\treturn Math.random().toString(36).substring(2);\n}\n\nexport function findClosest(tagName, element) {\n\twhile (element && element.tagName !== tagName) {\n\t\t// eslint-disable-next-line no-param-reassign\n\t\telement = element.parentNode;\n\t}\n\treturn element;\n}\n\nexport const isSSR = typeof window === \"undefined\";\n\nexport function addListener(target, type, handler) {\n\ttarget.addEventListener(type, handler);\n\treturn () => target.removeEventListener(type, handler);\n}\n", "import { isFunction } from \"./utils\";\n\n// We start from 1 here, so we can check if an origin id has been passed\n// by using `originId || <fallback>`\nexport const LINK_ID = 1;\nexport const ROUTE_ID = 2;\nexport const ROUTER_ID = 3;\nexport const USE_FOCUS_ID = 4;\nexport const USE_LOCATION_ID = 5;\nexport const USE_MATCH_ID = 6;\nexport const USE_NAVIGATE_ID = 7;\nexport const USE_PARAMS_ID = 8;\nexport const USE_RESOLVABLE_ID = 9;\nexport const USE_RESOLVE_ID = 10;\nexport const NAVIGATE_ID = 11;\n\nconst labels = {\n\t[LINK_ID]: \"Link\",\n\t[ROUTE_ID]: \"Route\",\n\t[ROUTER_ID]: \"Router\",\n\t[USE_FOCUS_ID]: \"useFocus\",\n\t[USE_LOCATION_ID]: \"useLocation\",\n\t[USE_MATCH_ID]: \"useMatch\",\n\t[USE_NAVIGATE_ID]: \"useNavigate\",\n\t[USE_PARAMS_ID]: \"useParams\",\n\t[USE_RESOLVABLE_ID]: \"useResolvable\",\n\t[USE_RESOLVE_ID]: \"useResolve\",\n\t[NAVIGATE_ID]: \"navigate\",\n};\n\nexport const createLabel = labelId => labels[labelId];\n\nexport function createIdentifier(labelId, props) {\n\tlet attr;\n\tif (labelId === ROUTE_ID) {\n\t\tattr = props.path ? `path=\"${props.path}\"` : \"default\";\n\t} else if (labelId === LINK_ID) {\n\t\tattr = `to=\"${props.to}\"`;\n\t} else if (labelId === ROUTER_ID) {\n\t\tattr = `basepath=\"${props.basepath || \"\"}\"`;\n\t}\n\treturn `<${createLabel(labelId)} ${attr || \"\"} />`;\n}\n\nexport function createMessage(labelId, message, props, originId) {\n\tconst origin = props && createIdentifier(originId || labelId, props);\n\tconst originMsg = origin ? `\\n\\nOccurred in: ${origin}` : \"\";\n\tconst label = createLabel(labelId);\n\tconst msg = isFunction(message) ? message(label) : message;\n\treturn `<${label}> ${msg}${originMsg}`;\n}\n\nexport const createMessageHandler = handler => (...args) =>\n\thandler(createMessage(...args));\n\nexport const fail = createMessageHandler(message => {\n\tthrow new Error(message);\n});\n\n// eslint-disable-next-line no-console\nexport const warn = createMessageHandler(console.warn);\n", "import {\n\tsegmentize,\n\tjoin,\n\taddQuery,\n\tstartsWith,\n\tparamRegex,\n\tisSplat,\n\tisRootSegment,\n\tisDynamic,\n\tstripSplat,\n\tnormalizePath,\n} from \"./paths\";\nimport { ROUTER_ID, fail } from \"./warning\";\nimport { isUndefined } from \"./utils\";\n\nconst SEGMENT_POINTS = 4;\nconst STATIC_POINTS = 3;\nconst DYNAMIC_POINTS = 2;\nconst SPLAT_PENALTY = 1;\nconst ROOT_POINTS = 1;\n\n/**\n * Score a route depending on how its individual segments look\n * @param {object} route\n * @param {number} index\n * @return {object}\n */\nexport function rankRoute(route, index) {\n\tconst score = route.default\n\t\t? 0\n\t\t: segmentize(route.fullPath).reduce((acc, segment) => {\n\t\t\t\tlet nextScore = acc;\n\t\t\t\tnextScore += SEGMENT_POINTS;\n\n\t\t\t\tif (isRootSegment(segment)) {\n\t\t\t\t\tnextScore += ROOT_POINTS;\n\t\t\t\t} else if (isDynamic(segment)) {\n\t\t\t\t\tnextScore += DYNAMIC_POINTS;\n\t\t\t\t} else if (isSplat(segment)) {\n\t\t\t\t\tnextScore -= SEGMENT_POINTS + SPLAT_PENALTY;\n\t\t\t\t} else {\n\t\t\t\t\tnextScore += STATIC_POINTS;\n\t\t\t\t}\n\n\t\t\t\treturn nextScore;\n\t\t  }, 0);\n\n\treturn { route, score, index };\n}\n\n/**\n * Give a score to all routes and sort them on that\n * @param {object[]} routes\n * @return {object[]}\n */\nexport function rankRoutes(routes) {\n\treturn (\n\t\troutes\n\t\t\t.map(rankRoute)\n\t\t\t// If two routes have the exact same score, we go by index instead\n\t\t\t.sort((a, b) => {\n\t\t\t\tif (a.score < b.score) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif (a.score > b.score) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn a.index - b.index;\n\t\t\t})\n\t);\n}\n\n/**\n * Ranks and picks the best route to match. Each segment gets the highest\n * amount of points, then the type of segment gets an additional amount of\n * points where\n *\n *  static > dynamic > splat > root\n *\n * This way we don't have to worry about the order of our routes, let the\n * computers do it.\n *\n * A route looks like this\n *\n *  { fullPath, default, value }\n *\n * And a returned match looks like:\n *\n *  { route, params, uri }\n *\n * @param {object[]} routes\n * @param {string} uri\n * @return {?object}\n */\nexport function pick(routes, uri) {\n\tlet bestMatch;\n\tlet defaultMatch;\n\n\tconst [uriPathname] = uri.split(\"?\");\n\tconst uriSegments = segmentize(uriPathname);\n\tconst isRootUri = uriSegments[0] === \"\";\n\tconst ranked = rankRoutes(routes);\n\n\tfor (let i = 0, l = ranked.length; i < l; i++) {\n\t\tconst { route } = ranked[i];\n\t\tlet missed = false;\n\t\tconst params = {};\n\n\t\t// eslint-disable-next-line no-shadow\n\t\tconst createMatch = uri => ({ ...route, params, uri });\n\n\t\tif (route.default) {\n\t\t\tdefaultMatch = createMatch(uri);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst routeSegments = segmentize(route.fullPath);\n\t\tconst max = Math.max(uriSegments.length, routeSegments.length);\n\t\tlet index = 0;\n\n\t\tfor (; index < max; index++) {\n\t\t\tconst routeSegment = routeSegments[index];\n\t\t\tconst uriSegment = uriSegments[index];\n\n\t\t\tif (!isUndefined(routeSegment) && isSplat(routeSegment)) {\n\t\t\t\t// Hit a splat, just grab the rest, and return a match\n\t\t\t\t// uri:   /files/documents/work\n\t\t\t\t// route: /files/* or /files/*splatname\n\t\t\t\tconst splatName = routeSegment === \"*\" ? \"*\" : routeSegment.slice(1);\n\n\t\t\t\tparams[splatName] = uriSegments\n\t\t\t\t\t.slice(index)\n\t\t\t\t\t.map(decodeURIComponent)\n\t\t\t\t\t.join(\"/\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (isUndefined(uriSegment)) {\n\t\t\t\t// URI is shorter than the route, no match\n\t\t\t\t// uri:   /users\n\t\t\t\t// route: /users/:userId\n\t\t\t\tmissed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst dynamicMatch = paramRegex.exec(routeSegment);\n\n\t\t\tif (dynamicMatch && !isRootUri) {\n\t\t\t\tconst value = decodeURIComponent(uriSegment);\n\t\t\t\tparams[dynamicMatch[1]] = value;\n\t\t\t} else if (routeSegment !== uriSegment) {\n\t\t\t\t// Current segments don't match, not dynamic, not splat, so no match\n\t\t\t\t// uri:   /users/123/settings\n\t\t\t\t// route: /users/:id/profile\n\t\t\t\tmissed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!missed) {\n\t\t\tbestMatch = createMatch(join(...uriSegments.slice(0, index)));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bestMatch || defaultMatch || null;\n}\n\n/**\n * Check if the `route.fullPath` matches the `uri`.\n * @param {Object} route\n * @param {string} uri\n * @return {?object}\n */\nexport function match(route, uri) {\n\treturn pick([route], uri);\n}\n\n/**\n * Resolve URIs as though every path is a directory, no files. Relative URIs\n * in the browser can feel awkward because not only can you be \"in a directory\",\n * you can be \"at a file\", too. For example:\n *\n *  browserSpecResolve('foo', '/bar/') => /bar/foo\n *  browserSpecResolve('foo', '/bar') => /foo\n *\n * But on the command line of a file system, it's not as complicated. You can't\n * `cd` from a file, only directories. This way, links have to know less about\n * their current path. To go deeper you can do this:\n *\n *  <Link to=\"deeper\"/>\n *  // instead of\n *  <Link to=`{${props.uri}/deeper}`/>\n *\n * Just like `cd`, if you want to go deeper from the command line, you do this:\n *\n *  cd deeper\n *  # not\n *  cd $(pwd)/deeper\n *\n * By treating every path as a directory, linking to relative paths should\n * require less contextual information and (fingers crossed) be more intuitive.\n * @param {string} to\n * @param {string} base\n * @return {string}\n */\nexport function resolve(to, base) {\n\t// /foo/bar, /baz/qux => /foo/bar\n\tif (startsWith(to, \"/\")) {\n\t\treturn to;\n\t}\n\n\tconst [toPathname, toQuery] = to.split(\"?\");\n\tconst [basePathname] = base.split(\"?\");\n\tconst toSegments = segmentize(toPathname);\n\tconst baseSegments = segmentize(basePathname);\n\n\t// ?a=b, /users?b=c => /users?a=b\n\tif (toSegments[0] === \"\") {\n\t\treturn addQuery(basePathname, toQuery);\n\t}\n\n\t// profile, /users/789 => /users/789/profile\n\tif (!startsWith(toSegments[0], \".\")) {\n\t\tconst pathname = baseSegments.concat(toSegments).join(\"/\");\n\t\treturn addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery);\n\t}\n\n\t// ./       , /users/123 => /users/123\n\t// ../      , /users/123 => /users\n\t// ../..    , /users/123 => /\n\t// ../../one, /a/b/c/d   => /a/b/one\n\t// .././one , /a/b/c/d   => /a/b/c/one\n\tconst allSegments = baseSegments.concat(toSegments);\n\tconst segments = [];\n\n\tallSegments.forEach(segment => {\n\t\tif (segment === \"..\") {\n\t\t\tsegments.pop();\n\t\t} else if (segment !== \".\") {\n\t\t\tsegments.push(segment);\n\t\t}\n\t});\n\n\treturn addQuery(`/${segments.join(\"/\")}`, toQuery);\n}\n\n/**\n * Normalizes a location for consumption by `Route` children and the `Router`.\n * It removes the apps basepath from the pathname\n * and sets default values for `search` and `hash` properties.\n *\n * @param {Object} location The current global location supplied by the history component\n * @param {string} basepath The applications basepath (i.e. when serving from a subdirectory)\n *\n * @returns The normalized location\n */\nexport function normalizeLocation(location, basepath) {\n\tconst { pathname, hash = \"\", search = \"\", state } = location;\n\tconst baseSegments = segmentize(basepath, true);\n\tconst pathSegments = segmentize(pathname, true);\n\twhile (baseSegments.length) {\n\t\tif (baseSegments[0] !== pathSegments[0]) {\n\t\t\tfail(\n\t\t\t\tROUTER_ID,\n\t\t\t\t`Invalid state: All locations must begin with the basepath \"${basepath}\", found \"${pathname}\"`,\n\t\t\t);\n\t\t}\n\t\tbaseSegments.shift();\n\t\tpathSegments.shift();\n\t}\n\treturn {\n\t\tpathname: join(...pathSegments),\n\t\thash,\n\t\tsearch,\n\t\tstate,\n\t};\n}\n\nconst normalizeUrlFragment = frag => (frag.length === 1 ? \"\" : frag);\n\n/**\n * Creates a location object from an url.\n * It is used to create a location from the url prop used in SSR\n *\n * @param {string} url The url string (e.g. \"/path/to/somewhere\")\n *\n * @returns {{ pathname: string; search: string; hash: string }} The location\n */\nexport function createLocation(url) {\n\tconst searchIndex = url.indexOf(\"?\");\n\tconst hashIndex = url.indexOf(\"#\");\n\tconst hasSearchIndex = searchIndex !== -1;\n\tconst hasHashIndex = hashIndex !== -1;\n\tconst hash = hasHashIndex ? normalizeUrlFragment(url.substr(hashIndex)) : \"\";\n\tconst pathnameAndSearch = hasHashIndex ? url.substr(0, hashIndex) : url;\n\tconst search = hasSearchIndex\n\t\t? normalizeUrlFragment(pathnameAndSearch.substr(searchIndex))\n\t\t: \"\";\n\tconst pathname = hasSearchIndex\n\t\t? pathnameAndSearch.substr(0, searchIndex)\n\t\t: pathnameAndSearch;\n\treturn { pathname, search, hash };\n}\n\n/**\n * Resolves a link relative to the parent Route and the Routers basepath.\n *\n * @param {string} path The given path, that will be resolved\n * @param {string} routeBase The current Routes base path\n * @param {string} appBase The basepath of the app. Used, when serving from a subdirectory\n * @returns {string} The resolved path\n *\n * @example\n * resolveLink(\"relative\", \"/routeBase\", \"/\") // -> \"/routeBase/relative\"\n * resolveLink(\"/absolute\", \"/routeBase\", \"/\") // -> \"/absolute\"\n * resolveLink(\"relative\", \"/routeBase\", \"/base\") // -> \"/base/routeBase/relative\"\n * resolveLink(\"/absolute\", \"/routeBase\", \"/base\") // -> \"/base/absolute\"\n */\nexport function resolveLink(path, routeBase, appBase) {\n\treturn join(appBase, resolve(path, routeBase));\n}\n\n/**\n * Get the uri for a Route, by matching it against the current location.\n *\n * @param {string} routePath The Routes resolved path\n * @param {string} pathname The current locations pathname\n */\nexport function extractBaseUri(routePath, pathname) {\n\tconst fullPath = normalizePath(stripSplat(routePath));\n\tconst baseSegments = segmentize(fullPath, true);\n\tconst pathSegments = segmentize(pathname, true).slice(0, baseSegments.length);\n\tconst routeMatch = match({ fullPath }, join(...pathSegments));\n\treturn routeMatch && routeMatch.uri;\n}\n", "/*\n * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js\n *\n * https://github.com/reach/router/blob/master/LICENSE\n */\n\nimport { createLocation } from \"./routes\";\nimport { createGlobalId, isSSR, isNumber, addListener } from \"./utils\";\nimport { warn, NAVIGATE_ID } from \"./warning\";\n\nconst POP = \"POP\";\nconst PUSH = \"PUSH\";\nconst REPLACE = \"REPLACE\";\n\nfunction getLocation(source) {\n\treturn {\n\t\t...source.location,\n\t\tpathname: encodeURI(decodeURI(source.location.pathname)),\n\t\tstate: source.history.state,\n\t\t_key: (source.history.state && source.history.state._key) || \"initial\",\n\t};\n}\n\nfunction createHistory(source) {\n\tlet listeners = [];\n\tlet location = getLocation(source);\n\tlet action = POP;\n\n\tconst notifyListeners = (listenerFns = listeners) =>\n\t\tlistenerFns.forEach(listener => listener({ location, action }));\n\n\treturn {\n\t\tget location() {\n\t\t\treturn location;\n\t\t},\n\t\tlisten(listener) {\n\t\t\tlisteners.push(listener);\n\n\t\t\tconst popstateListener = () => {\n\t\t\t\tlocation = getLocation(source);\n\t\t\t\taction = POP;\n\t\t\t\tnotifyListeners([listener]);\n\t\t\t};\n\n\t\t\t// Call listener when it is registered\n\t\t\tnotifyListeners([listener]);\n\n\t\t\tconst unlisten = addListener(source, \"popstate\", popstateListener);\n\t\t\treturn () => {\n\t\t\t\tunlisten();\n\t\t\t\tlisteners = listeners.filter(fn => fn !== listener);\n\t\t\t};\n\t\t},\n\t\t/**\n\t\t * Navigate to a new absolute route.\n\t\t *\n\t\t * @param {string|number} to The path to navigate to.\n\t\t *\n\t\t * If `to` is a number we will navigate to the stack entry index + `to`\n\t\t * (-> `navigate(-1)`, is equivalent to hitting the back button of the browser)\n\t\t * @param {Object} options\n\t\t * @param {*} [options.state] The state will be accessible through `location.state`\n\t\t * @param {boolean} [options.replace=false] Replace the current entry in the history\n\t\t * stack, instead of pushing on a new one\n\t\t */\n\t\tnavigate(to, options) {\n\t\t\tconst { state = {}, replace = false } = options || {};\n\t\t\taction = replace ? REPLACE : PUSH;\n\t\t\tif (isNumber(to)) {\n\t\t\t\tif (options) {\n\t\t\t\t\twarn(\n\t\t\t\t\t\tNAVIGATE_ID,\n\t\t\t\t\t\t\"Navigation options (state or replace) are not supported, \" +\n\t\t\t\t\t\t\t\"when passing a number as the first argument to navigate. \" +\n\t\t\t\t\t\t\t\"They are ignored.\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\taction = POP;\n\t\t\t\tsource.history.go(to);\n\t\t\t} else {\n\t\t\t\tconst keyedState = { ...state, _key: createGlobalId() };\n\t\t\t\t// try...catch iOS Safari limits to 100 pushState calls\n\t\t\t\ttry {\n\t\t\t\t\tsource.history[replace ? \"replaceState\" : \"pushState\"](\n\t\t\t\t\t\tkeyedState,\n\t\t\t\t\t\t\"\",\n\t\t\t\t\t\tto,\n\t\t\t\t\t);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tsource.location[replace ? \"replace\" : \"assign\"](to);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlocation = getLocation(source);\n\t\t\tnotifyListeners();\n\t\t},\n\t};\n}\n\nfunction createStackFrame(state, uri) {\n\treturn { ...createLocation(uri), state };\n}\n\n// Stores history entries in memory for testing or other platforms like Native\nfunction createMemorySource(initialPathname = \"/\") {\n\tlet index = 0;\n\tlet stack = [createStackFrame(null, initialPathname)];\n\n\treturn {\n\t\t// This is just for testing...\n\t\tget entries() {\n\t\t\treturn stack;\n\t\t},\n\t\tget location() {\n\t\t\treturn stack[index];\n\t\t},\n\t\taddEventListener() {},\n\t\tremoveEventListener() {},\n\t\thistory: {\n\t\t\tget state() {\n\t\t\t\treturn stack[index].state;\n\t\t\t},\n\t\t\tpushState(state, title, uri) {\n\t\t\t\tindex++;\n\t\t\t\t// Throw away anything in the stack with an index greater than the current index.\n\t\t\t\t// This happens, when we go back using `go(-n)`. The index is now less than `stack.length`.\n\t\t\t\t// If we call `go(+n)` the stack entries with an index greater than the current index can\n\t\t\t\t// be reused.\n\t\t\t\t// However, if we navigate to a path, instead of a number, we want to create a new branch\n\t\t\t\t// of navigation.\n\t\t\t\tstack = stack.slice(0, index);\n\t\t\t\tstack.push(createStackFrame(state, uri));\n\t\t\t},\n\t\t\treplaceState(state, title, uri) {\n\t\t\t\tstack[index] = createStackFrame(state, uri);\n\t\t\t},\n\t\t\tgo(to) {\n\t\t\t\tconst newIndex = index + to;\n\t\t\t\tif (newIndex < 0 || newIndex > stack.length - 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tindex = newIndex;\n\t\t\t},\n\t\t},\n\t};\n}\n\n// Global history uses window.history as the source if available,\n// otherwise a memory history\nconst canUseDOM = !!(\n\t!isSSR &&\n\twindow.document &&\n\twindow.document.createElement\n);\n// Use memory history in iframes (for example in Svelte REPL)\nconst isEmbeddedPage = !isSSR && window.location.origin === \"null\";\nconst globalHistory = createHistory(\n\tcanUseDOM && !isEmbeddedPage ? window : createMemorySource(),\n);\nconst { navigate } = globalHistory;\n\nexport { globalHistory, navigate, createHistory, createMemorySource };\n", "/*\n * Adapted from https://github.com/EmilTholin/svelte-routing\n *\n * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE\n */\n\nimport { navigate as defaultNavigate } from \"./history\";\nimport { shouldNavigate, findClosest, addListener, isFunction } from \"./utils\";\n\nconst createAction = getAnchor => (node, navigate = defaultNavigate) => {\n\tconst handleClick = event => {\n\t\tconst anchor = getAnchor(event);\n\t\tif (anchor && anchor.target === \"\" && shouldNavigate(event)) {\n\t\t\tevent.preventDefault();\n\t\t\tconst to = anchor.pathname + anchor.search + anchor.hash;\n\t\t\tnavigate(to, { replace: anchor.hasAttribute(\"replace\") });\n\t\t}\n\t};\n\tconst unlisten = addListener(node, \"click\", handleClick);\n\treturn { destroy: unlisten };\n};\n\n// prettier-ignore\n/**\n * A link action that can be added to <a href=\"\"> tags rather\n * than using the <Link> component.\n *\n * Example:\n * ```html\n * <a href=\"/post/{postId}\" use:link>{post.title}</a>\n * ```\n */\nexport const link = /*#__PURE__*/createAction(event => event.currentTarget); // eslint-disable-line spaced-comment, max-len\n\n// prettier-ignore\n/**\n * An action to be added at a root element of your application to\n * capture all relative links and push them onto the history stack.\n *\n * Example:\n * ```html\n * <div use:links>\n *   <Router>\n *     <Route path=\"/\" component={Home} />\n *     <Route path=\"/p/:projectId/:docId\" component={ProjectScreen} />\n *     {#each projects as project}\n *       <a href=\"/p/{project.id}\">{project.title}</a>\n *     {/each}\n *   </Router>\n * </div>\n * ```\n */\nexport const links = /*#__PURE__*/createAction(event => { // eslint-disable-line spaced-comment\n  const anchor = findClosest(\"A\", event.target);\n  if (\n    anchor &&\n    isFunction(anchor.hasAttribute) &&\n    !anchor.hasAttribute(\"noroute\")\n  ) {\n    return anchor;\n  }\n  return null;\n});\n", "/*\n * Adapted from https://github.com/EmilTholin/svelte-routing\n *\n * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE\n */\n\nconst createKey = ctxName => `@@svnav-ctx__${ctxName}`;\n\n// Use strings instead of objects, so different versions of\n// svelte-navigator can potentially still work together\nexport const LOCATION = createKey(\"LOCATION\");\nexport const ROUTER = createKey(\"ROUTER\");\nexport const ROUTE = createKey(\"ROUTE\");\nexport const ROUTE_PARAMS = createKey(\"ROUTE_PARAMS\");\nexport const FOCUS_ELEM = createKey(\"FOCUS_ELEM\");\n", "import { getContext, onDestroy, tick } from \"svelte\";\nimport { derived, get, writable } from \"svelte/store\";\nimport { LOCATION, ROUTER, ROUTE, ROUTE_PARAMS, FOCUS_ELEM } from \"./contexts\";\nimport { resolveLink, match, normalizeLocation } from \"./routes\";\nimport { isNumber } from \"./utils\";\nimport {\n\tfail,\n\tcreateLabel,\n\tUSE_FOCUS_ID,\n\tROUTER_ID,\n\tUSE_LOCATION_ID,\n\tROUTE_ID,\n\tUSE_RESOLVE_ID,\n\tUSE_RESOLVABLE_ID,\n\tUSE_NAVIGATE_ID,\n\tUSE_MATCH_ID,\n\tUSE_PARAMS_ID,\n} from \"./warning\";\n\n/**\n * Check if a component or hook have been created outside of a\n * context providing component\n * @param {number} componentId\n * @param {*} props\n * @param {string?} ctxKey\n * @param {number?} ctxProviderId\n */\nexport function usePreflightCheck(\n\tcomponentId,\n\tprops,\n\tctxKey = ROUTER,\n\tctxProviderId = ROUTER_ID,\n) {\n\tconst ctx = getContext(ctxKey);\n\tif (!ctx) {\n\t\tfail(\n\t\t\tcomponentId,\n\t\t\tlabel =>\n\t\t\t\t`You cannot use ${label} outside of a ${createLabel(ctxProviderId)}.`,\n\t\t\tprops,\n\t\t);\n\t}\n}\n\nconst toReadonly = ctx => {\n\tconst { subscribe } = getContext(ctx);\n\treturn { subscribe };\n};\n\n/**\n * Access the current location via a readable store.\n * @returns {import(\"svelte/store\").Readable<{\n    pathname: string;\n    search: string;\n    hash: string;\n    state: {};\n  }>}\n *\n * @example\n  ```html\n  <script>\n    import { useLocation } from \"svelte-navigator\";\n\n    const location = useLocation();\n\n    $: console.log($location);\n    // {\n    //   pathname: \"/blog\",\n    //   search: \"?id=123\",\n    //   hash: \"#comments\",\n    //   state: {}\n    // }\n  </script>\n  ```\n */\nexport function useLocation() {\n\tusePreflightCheck(USE_LOCATION_ID);\n\treturn toReadonly(LOCATION);\n}\n\n/**\n * @typedef {{\n    path: string;\n    fullPath: string;\n    uri: string;\n    params: {};\n  }} RouteMatch\n */\n\n/**\n * @typedef {import(\"svelte/store\").Readable<RouteMatch|null>} RouteMatchStore\n */\n\n/**\n * Access the history of top level Router.\n */\nexport function useHistory() {\n\tconst { history } = getContext(ROUTER);\n\treturn history;\n}\n\n/**\n * Access the base of the parent Route.\n */\nexport function useRouteBase() {\n\tconst route = getContext(ROUTE);\n\treturn route ? derived(route, _route => _route.base) : writable(\"/\");\n}\n\n/**\n * Resolve a given link relative to the current `Route` and the `Router`s `basepath`.\n * It is used under the hood in `Link` and `useNavigate`.\n * You can use it to manually resolve links, when using the `link` or `links` actions.\n *\n * @returns {(path: string) => string}\n *\n * @example\n  ```html\n  <script>\n    import { link, useResolve } from \"svelte-navigator\";\n\n    const resolve = useResolve();\n    // `resolvedLink` will be resolved relative to its parent Route\n    // and the Routers `basepath`\n    const resolvedLink = resolve(\"relativePath\");\n  </script>\n\n  <a href={resolvedLink} use:link>Relative link</a>\n  ```\n */\nexport function useResolve() {\n\tusePreflightCheck(USE_RESOLVE_ID);\n\tconst routeBase = useRouteBase();\n\tconst { basepath: appBase } = getContext(ROUTER);\n\t/**\n\t * Resolves the path relative to the current route and basepath.\n\t *\n\t * @param {string} path The path to resolve\n\t * @returns {string} The resolved path\n\t */\n\tconst resolve = path => resolveLink(path, get(routeBase), appBase);\n\treturn resolve;\n}\n\n/**\n * Resolve a given link relative to the current `Route` and the `Router`s `basepath`.\n * It is used under the hood in `Link` and `useNavigate`.\n * You can use it to manually resolve links, when using the `link` or `links` actions.\n *\n * @returns {import(\"svelte/store\").Readable<string>}\n *\n * @example\n  ```html\n  <script>\n    import { link, useResolvable } from \"svelte-navigator\";\n\n    // `resolvedLink` will be resolved relative to its parent Route\n    // and the Routers `basepath`.\n    const resolvedLink = useResolvable(\"relativePath\");\n  </script>\n\n  <a href={$resolvedLink} use:link>Relative link</a>\n  ```\n */\nexport function useResolvable(path) {\n\tusePreflightCheck(USE_RESOLVABLE_ID);\n\tconst routeBase = useRouteBase();\n\tconst { basepath: appBase } = getContext(ROUTER);\n\treturn derived(routeBase, _routeBase =>\n\t\tresolveLink(path, _routeBase, appBase),\n\t);\n}\n\n/**\n * A hook, that returns a context-aware version of `navigate`.\n * It will automatically resolve the given link relative to the current Route.\n * It will also resolve a link against the `basepath` of the Router.\n *\n * @example\n  ```html\n  <!-- App.svelte -->\n  <script>\n    import { link, Route } from \"svelte-navigator\";\n    import RouteComponent from \"./RouteComponent.svelte\";\n  </script>\n\n  <Router>\n    <Route path=\"route1\">\n      <RouteComponent />\n    </Route>\n    <!-- ... -->\n  </Router>\n\n  <!-- RouteComponent.svelte -->\n  <script>\n    import { useNavigate } from \"svelte-navigator\";\n\n    const navigate = useNavigate();\n  </script>\n\n  <button on:click=\"{() => navigate('relativePath')}\">\n    go to /route1/relativePath\n  </button>\n  <button on:click=\"{() => navigate('/absolutePath')}\">\n    go to /absolutePath\n  </button>\n  ```\n  *\n  * @example\n  ```html\n  <!-- App.svelte -->\n  <script>\n    import { link, Route } from \"svelte-navigator\";\n    import RouteComponent from \"./RouteComponent.svelte\";\n  </script>\n\n  <Router basepath=\"/base\">\n    <Route path=\"route1\">\n      <RouteComponent />\n    </Route>\n    <!-- ... -->\n  </Router>\n\n  <!-- RouteComponent.svelte -->\n  <script>\n    import { useNavigate } from \"svelte-navigator\";\n\n    const navigate = useNavigate();\n  </script>\n\n  <button on:click=\"{() => navigate('relativePath')}\">\n    go to /base/route1/relativePath\n  </button>\n  <button on:click=\"{() => navigate('/absolutePath')}\">\n    go to /base/absolutePath\n  </button>\n  ```\n */\nexport function useNavigate() {\n\tusePreflightCheck(USE_NAVIGATE_ID);\n\tconst resolve = useResolve();\n\tconst { navigate } = useHistory();\n\t/**\n\t * Navigate to a new route.\n\t * Resolves the link relative to the current route and basepath.\n\t *\n\t * @param {string|number} to The path to navigate to.\n\t *\n\t * If `to` is a number we will navigate to the stack entry index + `to`\n\t * (-> `navigate(-1)`, is equivalent to hitting the back button of the browser)\n\t * @param {Object} options\n\t * @param {*} [options.state]\n\t * @param {boolean} [options.replace=false]\n\t */\n\tconst navigateRelative = (to, options) => {\n\t\t// If to is a number, we navigate to the target stack entry via `history.go`.\n\t\t// Otherwise resolve the link\n\t\tconst target = isNumber(to) ? to : resolve(to);\n\t\treturn navigate(target, options);\n\t};\n\treturn navigateRelative;\n}\n\n/**\n * Use Svelte Navigators matching without needing to use a Route.\n * Returns a readable store with the potential match,\n * that changes, when the location changes.\n *\n * The provided path will be resolved relatively,\n * as you're used to with all paths in Svelte Navigator\n *\n * @param {string} path The path, to match against.\n * It works just like a Route path\n * @returns {RouteMatchStore} The matched route.\n * Returns `null`, when nothing could be matched\n *\n * @example\n  ```html\n  <script>\n    import { useMatch } from \"svelte-navigator\";\n\n    const relativeMatch = useMatch(\"relative/path/:to/*somewhere\");\n    const absoluteMatch = useMatch(\"/absolute/path/:to/*somewhere\");\n\n    $: console.log($relativeMatch.params.to);\n    $: console.log($absoluteMatch.params.somewhere);\n  </script>\n  ```\n */\nexport function useMatch(path) {\n\tusePreflightCheck(USE_MATCH_ID);\n\tconst location = useLocation();\n\tconst resolve = useResolve();\n\tconst { basepath: appBase } = getContext(ROUTER);\n\tconst resolvedPath = resolve(path);\n\tconst { pathname: fullPath } = normalizeLocation(\n\t\t{ pathname: resolvedPath },\n\t\tappBase,\n\t);\n\treturn derived(location, loc => match({ fullPath, path }, loc.pathname));\n}\n\n/**\n * Access the parent Routes matched params and wildcards\n * @returns {import(\"svelte/store\").Readable<{\n     [param: string]: any;\n   }>} A readable store containing the matched parameters and wildcards\n *\n * @example\n  ```html\n  <!--\n    Somewhere inside <Route path=\"user/:id/*splat\" />\n    with a current url of \"/myApp/user/123/pauls-profile\"\n  -->\n  <script>\n    import { useParams } from \"svelte-navigator\";\n\n    const params = useParams();\n\n    $: console.log($params); // -> { id: \"123\", splat: \"pauls-profile\" }\n  </script>\n\n  <h3>Welcome user {$params.id}! bleep bloop...</h3>\n  ```\n */\nexport function useParams() {\n\tusePreflightCheck(USE_PARAMS_ID, null, ROUTE, ROUTE_ID);\n\treturn toReadonly(ROUTE_PARAMS);\n}\n\n/**\n * Provide a custom element to focus, when the parent route is visited.\n * It returns the `registerFocus` function you can call manually with an\n * Element or use as a Svelte action via the `use` directive.\n *\n * @example\n  ```html\n  <!-- Using `registerFocus` as a Svelte action: -->\n  <!-- Somewhere inside a Route -->\n  <script>\n    import { useFocus } from \"svelte-navigator\";\n\n    const registerFocus = useFocus();\n  </script>\n\n  <h1>Don't worry about me...</h1>\n  <p use:registerFocus>Here, look at me!</p>\n  ```\n  * @example\n  ```html\n  <!-- Calling `registerFocus` manually: -->\n  <!-- Somewhere inside a Route -->\n  <script>\n    import { onMount } from \"svelte\";\n    import { useFocus } from \"svelte-navigator\";\n\n    const registerFocus = useFocus();\n\n    let focusElement;\n\n    onMount(() => registerFocus(focusElement))\n  </script>\n\n  <h1>Don't worry about me...</h1>\n  <p bind:this={focusElement}>Here, look at me!</p>\n  ```\n  * @example\n  ```html\n  <!-- Using `registerFocus` asyncronously: -->\n  <!-- Somewhere inside a Route -->\n  <script>\n    import { onMount } from \"svelte\";\n    import { useFocus } from \"svelte-navigator\";\n\n    const registerFocus = useFocus();\n\n    const lazyImport = import(\"./MyComponent.svelte\").then(module => module.default);\n  </script>\n\n  {#await lazyImport then MyComponent}\n    <MyComponent {registerFocus} />\n  {/await}\n\n  <!-- MyComponent.svelte -->\n  <script>\n    export let registerFocus;\n  </script>\n\n  <h1 use:registerFocus>Hi there!</h1>\n  ```\n */\nexport function useFocus() {\n\tusePreflightCheck(USE_FOCUS_ID, null, ROUTE, ROUTE_ID);\n\tconst location = useLocation();\n\tconst focusElement = getContext(FOCUS_ELEM);\n\n\tlet resolve;\n\tconst unsubscribe = location.subscribe(() => {\n\t\tconst lazyElement = new Promise(_resolve => {\n\t\t\tresolve = _resolve;\n\t\t});\n\t\tfocusElement.set(lazyElement);\n\t});\n\n\tonDestroy(unsubscribe);\n\n\treturn node => {\n\t\tlet unmounted = false;\n\t\tconst innerUnsubscribe = location.subscribe(() => {\n\t\t\ttick().then(() => {\n\t\t\t\tif (!unmounted) {\n\t\t\t\t\tresolve(node);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn {\n\t\t\tdestroy() {\n\t\t\t\tunmounted = true;\n\t\t\t\tinnerUnsubscribe();\n\t\t\t},\n\t\t};\n\t};\n}\n"],
  "mappings": "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",
  "names": []
}
